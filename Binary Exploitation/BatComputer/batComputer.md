# BatComputer
We begin by testing how we expect the program to run with a test input:

```
Welcome to your BatComputer, Batman. What would you like to do?
1. Track Joker
2. Chase Joker
>
```
Selecting option 1, we get an address before the loop restarts.
```
It was very hard, but Alfred managed to locate him: 0x7ffc052bb864
```
If we then select option 2, the program requires a password. Let's take a look at the binary code through BinaryNinja
to see if we can figure out the password!

## Code
```
000011ec  int32_t main(int32_t argc, char** argv, char** envp)

000011f9      sub_11a9()
000011f9      
00001213      while (true)
00001213          void var_64
00001213          memset(&var_64, 0, 0x10)
00001224          printf(format: "Welcome to your BatComputer, Bat…")
0000123c          int32_t var_68
0000123c          __isoc99_scanf(format: &data_2069, &var_68)
00001247          void buf
00001247          
00001247          if (var_68 != 1)
0000126d              if (var_68 != 2)
00001314                  puts(str: "Too bad, now who's gonna save Go…")
0000131f                  return 0
0000131f              
0000127f              printf(format: "Ok. Let's do this. Enter the pas…")
0000129b              __isoc99_scanf(format: "%15s", &var_64)
0000129b              
000012b9              if (strcmp(&var_64, "b4tp@$$w0rd!") != 0)
000012b9                  break
000012b9              
000012dd              printf(format: "Access Granted. \nEnter the navi…")
000012f7              read(fd: 0, &buf, nbytes: 0x89)
00001303              puts(str: "Roger that!")
00001247          else
00001260              printf(format: "It was very hard, but Alfred man…", &buf)
00001260      
000012c2      puts(str: "The password is wrong.\nI can't …")
000012cc      exit(status: 0)
000012cc      noreturn

```
We can see that the password is 'b4tp@$$w0rd!', after which the program reads 0x89=137 bytes from standard input. An immediiate vulnerability we can see
is the use of the 'reads' function to store the bytes into buf. Since this buffer is so big, something we can try is to inject shell code into the machine.
Since we're given the address of the buffer, as seen on line 0x1260, we can try to fill the start of the buffer with shellcode (code that opens a shell 
when executed), then overflow the buffer until we reach the return address of the main function, after which we replace the return address with the address
of our buffer. This way, once the function returns, it'll go to execute what is stored our buffer, which is the shellcode we injected.

## Exploit Formation
Some more work must first be done before we can complete the exploit. The most important thing is to find how much we need to overflow the buffer by to reach
the return address of the main function. Let's use GDB to help us out!
Unfortunately, as the binary is stripped, we cannot disass main to set break points for analysis. Instead, we can use CTRL+C to interrupt the program, and
get the following GDB code:
```
Program received signal SIGINT, Interrupt.
0x00007ffff7e9f7e2 in __GI___libc_read (fd=0, buf=0x7ffff7fa5b23 <_IO_2_1_stdin_+131>, nbytes=1) at ../sysdeps/unix/sysv/linux/read.c:26
26      ../sysdeps/unix/sysv/linux/read.c: No such file or directory.
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
──────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────────────────────────────────────
 RAX  0xfffffffffffffe00
 RBX  0x7ffff7fa5aa0 (_IO_2_1_stdin_) ◂— 0xfbad208b
 RCX  0x7ffff7e9f7e2 (read+18) ◂— cmp rax, -0x1000 /* 'H=' */
 RDX  1
 RDI  0
 RSI  0x7ffff7fa5b23 (_IO_2_1_stdin_+131) ◂— 0xfa7a800000000000
 R8   0
 R9   0x7ffff7fc9040 (_dl_fini) ◂— endbr64
 R10  0xffffffffffffff80
 R11  0x246
 R12  0x7ffff7fa6780 (_IO_2_1_stdout_) ◂— 0xfbad2887
 R13  0xd68
 R14  0x7ffff7fa1a00 (_IO_helper_jumps) ◂— 0
 R15  0xd68
 RBP  0x7ffff7fa2600 (_IO_file_jumps) ◂— 0
 RSP  0x7fffffffd6b8 —▸ 0x7ffff7e17c36 (_IO_file_underflow+390) ◂— test rax, rax
 RIP  0x7ffff7e9f7e2 (read+18) ◂— cmp rax, -0x1000 /* 'H=' */
───────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────────────────────────────────────────────────────
 ► 0x7ffff7e9f7e2 <read+18>                   cmp    rax, -0x1000     0xfffffffffffffe00 - -0x1000     EFLAGS => 0x206 [ cf PF af zf sf IF df of ]
   0x7ffff7e9f7e8 <read+24>                 ✔ ja     read+112                    <read+112>
    ↓
   0x7ffff7e9f840 <read+112>                  mov    rdx, qword ptr [rip + 0x1055c9]     RDX, [0x7ffff7fa4e10] => 0xffffffffffffff80
   0x7ffff7e9f847 <read+119>                  neg    eax
   0x7ffff7e9f849 <read+121>                  mov    dword ptr fs:[rdx], eax             [0x7ffff7d88740] => 0x200
   0x7ffff7e9f84c <read+124>                  mov    rax, 0xffffffffffffffff             RAX => -1
   0x7ffff7e9f853 <read+131>                  ret                                <_IO_file_underflow+390>
    ↓
   0x7ffff7e17c36 <_IO_file_underflow+390>    test   rax, rax                    0xffffffffffffffff & 0xffffffffffffffff     EFLAGS => 0x286 [ cf PF af zf SF IF df of ]
   0x7ffff7e17c39 <_IO_file_underflow+393>  ✔ jle    _IO_file_underflow+472      <_IO_file_underflow+472>
    ↓
   0x7ffff7e17c88 <_IO_file_underflow+472>    mov    qword ptr [rbx + 0x90], 0xffffffffffffffff     [_IO_2_1_stdin_+144] => 0xffffffffffffffff
   0x7ffff7e17c93 <_IO_file_underflow+483>    mov    edx, dword ptr [rbx]                           EDX, [_IO_2_1_stdin_] => 0xfbad208b
─────────────────────────────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffd6b8 —▸ 0x7ffff7e17c36 (_IO_file_underflow+390) ◂— test rax, rax
01:0008│     0x7fffffffd6c0 —▸ 0x7fffffffd800 —▸ 0x55555555606a ◂— 0x7449000000000064 /* 'd' */
02:0010│     0x7fffffffd6c8 —▸ 0x7ffff7da8d9a ◂— '__tunable_get_val'
03:0018│     0x7fffffffd6d0 —▸ 0x7ffff7fbb4d0 —▸ 0x7ffff7ffe5a0 —▸ 0x7ffff7fbb690 —▸ 0x7ffff7ffe2e0 ◂— ...
04:0020│     0x7fffffffd6d8 —▸ 0x7ffff7fa5aa0 (_IO_2_1_stdin_) ◂— 0xfbad208b
05:0028│     0x7fffffffd6e0 —▸ 0x7ffff7fa2600 (_IO_file_jumps) ◂— 0
06:0030│     0x7fffffffd6e8 —▸ 0x7ffff7fa6580 (_nl_global_locale) —▸ 0x7ffff7fa2820 (_nl_C_LC_CTYPE) —▸ 0x7ffff7f651c2 (_nl_C_name) ◂— 0x636d656d5f5f0043 /* 'C' */
07:0038│     0x7fffffffd6f0 ◂— 0xffffffffffffff80
───────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────────────────────────────
 ► 0   0x7ffff7e9f7e2 read+18
   1   0x7ffff7e17c36 _IO_file_underflow+390
   2   0x7ffff7e18d96 _IO_default_uflow+54
   3   0x7ffff7dee0d0 __vfscanf_internal+1776
   4   0x7ffff7ded142 __isoc99_scanf+178
   5   0x555555555241 None
   6   0x7ffff7db4d90 __libc_start_call_main+128
   7   0x7ffff7db4e40 __libc_start_main+128
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```
Notice at the bottom of the Backtrace section, we have number 5, which is called from __libc_start_call_main+128. This is the line in main which calls 'read', and so 
it is part of the main function before the while(true) loop restarts. We can use this as a break point to find the return address of main.
```
pwndbg> i f
Stack level 0, frame at 0x7fffffffdf90:
 rip = 0x555555555241; saved rip = 0x7ffff7db4d90
 called by frame at 0x7fffffffe030
 Arglist at 0x7fffffffdf18, args:
 Locals at 0x7fffffffdf18, Previous frame's sp is 0x7fffffffdf90
 Saved registers:
  rbp at 0x7fffffffdf80, rip at 0x7fffffffdf88
```
This shows that the return address (the register rip) is stored at 0x7fffffffdf88. Running the program, we get the start of the buffer is 0x7fffffffdf34. The difference
between these two addresses is 0x54=84 bytes, so we need to fill the input with 84 - length of shellcode to reach the return address. Then, we inject the address of the
buffer to complete the exploit. 

Exploit: [here](exploit.py)

## My Takeaways
This exercise taught me how to dig through the code when it was PIE (position independent executable) protected, meaning its memory addresses were altered on every
execution. I got great experience learning how to use the GDB break point system and reading through the error outputs to find the position of code. It was also my 
first time playing around with shellcode, and understanding how the injection works by running data that I wrote, mistaking it for code as it believes the address it
is returning to is the return address. An example of how mixing data and control creates vulnerabilities in systems.