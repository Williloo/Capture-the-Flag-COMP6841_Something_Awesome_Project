# Jeeves
We begin by testing how we expect the program to run with a test input:

```
Hello, good sir!
May I have your name? test
Hello test, hope you have a good day!
```

We can now open up the binary using BinaryNinja to inspect the code.

## Code
```
000011e9  int32_t main(int32_t argc, char** argv, char** envp)

000011e9  {
000011f5      int32_t var_c = 0xdeadc0d3;
00001208      printf("Hello, good sir!\nMay I have you…");
00001219      void buf;
00001219      gets(&buf);
00001231      printf("Hello %s, hope you have a good d…", &buf);
00001231      
0000123d      if (var_c == 0x1337bab3)
0000123d      {
00001244          int64_t buf_1 = malloc(0x100);
0000125e          int32_t fd = open("flag.txt", 0);
0000127c          read(fd, buf_1, 0x100);
00001294          printf("Pleased to make your acquaintanc…", buf_1);
000012a3          close(fd);
0000123d      }
0000123d      
000012ae      return 0;
000011e9  }
```

Because the function uses the gets function, we can suspect that this is a **buffer overflow** attack!

## Exploit Formation
To exploit this vulnerability, I want to first locate the position of the buffer, then find where var_c is stored, so that I can overflow the buffer
to alter var_c. Using GDB debugger, I set a break point at 0x555555555231 (attained from my gdb disassembly code using the command 'disass main') to
examine where var_c is stored. The output is as follows:
```
00:0000│ rsi rsp 0x7fffffffdf50 ◂— 'AAAAAAAA'
01:0008│-038     0x7fffffffdf58 ◂— 0x10101000000
02:0010│-030     0x7fffffffdf60 ◂— 2
03:0018│-028     0x7fffffffdf68 ◂— 0x1f8bfbff
04:0020│-020     0x7fffffffdf70 —▸ 0x7fffffffe309 ◂— 0x34365f363878 /* 'x86_64' */
05:0028│-018     0x7fffffffdf78 ◂— 0x64 /* 'd' */
06:0030│-010     0x7fffffffdf80 ◂— 0x1000
07:0038│-008     0x7fffffffdf88 ◂— 0xdeadc0d355555100
```
We can see that 0xdeadc0de3 is stored 0x38 bytes away from the start of the buffer. We can also see that there is 4 bytes of free space before '0xdeadc0d3'
(little Endian format), meaning to overflow the buffer and reach the start of var_c, we must fill 0x3B = 60 bytes. This can be done by sending 60 A's, then
the payload 0x1337bab3.

Exploit: [here](exploit.py)

## My Takeaways
I was initially stumped because I thought the offset was 0x38 bytes, forgettinng the little endian format. As this was my first real taste of capture the flag,
I wasn't too familiar with how to use GDB. This gave me a great oppurtunity to explore what the output message actually meant, and utilise it to identify that
there was 4 extra bytes before the start of my offset. 