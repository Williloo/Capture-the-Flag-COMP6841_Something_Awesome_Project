# Optimistic
We begin by testing how we expect the program to run with a test input:

```
Welcome to the positive community!
We help you embrace optimism.
Would you like to enroll yourself? (y/n): y
Great! Here's a small welcome gift: 0x7fff8acc8710
Please provide your details.
Email: AAAA
Age: 23
Length of name: 7
Name: Will
Thank you! We'll be in touch soon.
```
Note that selecting 'n' for the first question results in terminating the program. Furthermore, inputting a large number for 'Length of Name'
also terminates the program. As there are so many prompts, let's have a look through Binary Ninja!

## Code
```
00001229  int32_t main(int32_t argc, char** argv, char** envp)

00001229  {
00001236      initialize();
00001242      puts("Welcome to the positive communit…");
0000124e      puts("We help you embrace optimism.");
0000125f      printf("Would you like to enroll yoursel…");
00001264      char rax_2 = getchar();
0000126c      getchar();
0000126c      
00001277      if (rax_2 != 0x79)
00001277      {
00001280          puts("Too bad, see you next time :(");
00001285          char var_79 = 0x6e;
0000128e          exit(0);
0000128e          /* no return */
00001277      }
00001277      
000012a5      int64_t __saved_rbp;
000012a5      printf("Great! Here's a small welcome gi…", &__saved_rbp);
000012b1      puts("Please provide your details.");
000012c2      printf("Email: ");
000012e6      void buf;
000012e6      int16_t var_7c = read(0, &buf, 8);
000012f6      printf("Age: ");
0000131a      void buf_1;
0000131a      int32_t var_80 = read(0, &buf_1, 8);
00001329      printf("Length of name: ");
00001345      uint32_t i;
00001345      __isoc99_scanf(&data_2104, &i);
00001345      
00001350      if (i > 0x40)
00001350      {
00001359          puts("Woah there! You shouldn't be too…");
00001363          exit(0);
00001363          /* no return */
00001350      }
00001350      
00001374      printf("Name: ");
00001393      void buf_2;
00001393      int32_t rax_17 = read(0, &buf_2, ((uint64_t)i));
00001393      
000013fb      for (i = 0; i < (rax_17 - 9); i += 1)
000013fb      {
000013cf          if ((isalpha(((int32_t)*(uint8_t*)(&buf_2 + ((int64_t)i)))) == 0 && (((int32_t)*(uint8_t*)(&buf_2 + ((int64_t)i))) - 0x30) > 9))
000013cf          {
000013d8              puts("Sorry, that's an invalid name.");
000013e2              exit(0);
000013e2              /* no return */
000013cf          }
000013fb      }
000013fb      
0000140b      return puts("Thank you! We'll be in touch soo…");
00001229  }
```
There's a lot of code to unpack, but let's have a look step by step:
- The first 'if' clause checks if our input character is 'y'. If not, it breaks
- We get the address of the rbp register, which is the location of the Stack
- We read in 8 bytes for our 'email'
- We read in 8 bytes for our Age
- We read in an unsigned int i, and if its greater than 0x40=64 bytes, we exit the program
- We read in (unsigned) i number of bytes into buf_2
- We check if each character read in buf_2 is alphabetical

From here, there are a few vulnerabilities we can exploit. Firstly, the unsigned int i comparison with 0x40 can be overflowed by inputting negative numbers.
Using this, we can enlarge the buffer nearly infinitely for the following read function, which allows us the potential of remote code execution by injecting shellcode into 
the system. This can be done so long as we alter the return address of the main function to be that of the start of our buffer, hence executing our shellcode 
as soon as main function returns.

## Exploit Formation
We must first find where the buffer is located. Using GDB and a test input, we get the following output:
```
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
─────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────
 RAX  0x23
 RBX  0
 RCX  0x7ffff7e9f887 (write+23) ◂— cmp rax, -0x1000 /* 'H=' */
 RDX  1
 RDI  0x7ffff7fa7a70 (_IO_stdfile_1_lock) ◂— 0
 RSI  1
 R8   0x22
 R9   0
 R10  0x7ffff7d9a8d0 ◂— 0xf001200000ef4
 R11  0x246
 R12  0x7fffffffe108 —▸ 0x7fffffffe38f ◂— '/mnt/c/users/willi/Downloads/optimistic'
 R13  0x555555555229 (main) ◂— push rbp
 R14  0
 R15  0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 —▸ 0x555555554000 ◂— 0x10102464c457f
 RBP  0x7fffffffdff0 ◂— 1
 RSP  0x7fffffffdf70 ◂— 0x60000000f
 RIP  0x55555555540a (main+481) ◂— leave
──────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────
 ► 0x55555555540a <main+481>                      leave
   0x55555555540b <main+482>                      ret                                <__libc_start_call_main+128>
    ↓
   0x7ffff7db4d90 <__libc_start_call_main+128>    mov    edi, eax     EDI => 0x23
   0x7ffff7db4d92 <__libc_start_call_main+130>    call   exit                        <exit>

   0x7ffff7db4d97 <__libc_start_call_main+135>    call   __nptl_deallocate_tsd       <__nptl_deallocate_tsd>

   0x7ffff7db4d9c <__libc_start_call_main+140>    lock dec dword ptr [rip + 0x1f0505]
   0x7ffff7db4da3 <__libc_start_call_main+147>    sete   al
   0x7ffff7db4da6 <__libc_start_call_main+150>    test   al, al
   0x7ffff7db4da8 <__libc_start_call_main+152>    jne    __libc_start_call_main+168  <__libc_start_call_main+168>

   0x7ffff7db4daa <__libc_start_call_main+154>    mov    edx, 0x3c     EDX => 0x3c
   0x7ffff7db4daf <__libc_start_call_main+159>    nop
───────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffdf70 ◂— 0x60000000f
01:0008│-078 0x7fffffffdf78 ◂— 0x79000500000002
02:0010│-070 0x7fffffffdf80 ◂— 0xa41414141 /* 'AAAA\n' */
03:0018│-068 0x7fffffffdf88 ◂— 0xa31 /* '1\n' */
04:0020│-060 0x7fffffffdf90 ◂— 'WILLILOOOOOOOO\n'
05:0028│-058 0x7fffffffdf98 ◂— 0xa4f4f4f4f4f4f /* 'OOOOOO\n' */
06:0030│-050 0x7fffffffdfa0 ◂— 0x6f0
07:0038│-048 0x7fffffffdfa8 —▸ 0x7fffffffe369 ◂— 0x496148f73d9e2255
─────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────
 ► 0   0x55555555540a main+481
   1   0x7ffff7db4d90 __libc_start_call_main+128
   2   0x7ffff7db4e40 __libc_start_main+128
   3   0x5555555550ee _start+46
────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```
We can see that my test inpput is stored at -0x60=-96 of the stack frame. Hence, since I received the location of my stack, my buffer is
simply stored at rbp-96. Now, I want to find where my return address of my main is stored. Using GDB again, I can use the i f (info frames)
to find the location of my rip register (return address):
```
Stack level 0, frame at 0x7fffffffe000:
 rip = 0x55555555540a in main; saved rip = 0x7ffff7db4d90
 called by frame at 0x7fffffffe0a0
 Arglist at 0x7fffffffdff0, args:
 Locals at 0x7fffffffdff0, Previous frame's sp is 0x7fffffffe000
 Saved registers:
  rbp at 0x7fffffffdff0, rip at 0x7fffffffdff8
```
My RIP is stored at 0x7fffffffdff8, whereas from before, I can find my buffer is located at 0x7fffffffdf90. Thus, I need to fill 
0x7fffffffdff8-0x7fffffffdf90=0x68=104 bytes to get from my buffer to my address. This forms my payload, which is shellcode, followed
by 104-length of shell code arbitrary bits, followed by the location of my buffer, rbp-96.

Exploit: [here](exploit.py)