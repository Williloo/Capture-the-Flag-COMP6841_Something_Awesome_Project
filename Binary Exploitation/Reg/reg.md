# Reg 
Let's have a look at what happens when we run the code file:
```
Enter your name : Williloo
Registered!
```
Seems like a simple read function-maybe a buffer overflow attack? Let's have a look at the binary using CodeNinja to figure out how to crack this!

## Code
```
00401206  int64_t winner()

00401206  {
00401218      puts("Congratulations!");
0040122b      FILE* fp = fopen("flag.txt", &data_402015);
00401247      void var_418;
00401247      fgets(&var_418, 0x400, fp);
00401256      puts(&var_418);
00401269      return fclose(fp);
00401206  }


0040126a  int64_t run()

0040126a  {
00401277      initialize();
00401288      printf("Enter your name : ");
00401299      void buf;
00401299      gets(&buf);
004012ac      return puts("Registered!");
0040126a  }


004012ad  int32_t main(int32_t argc, char** argv, char** envp)

004012ad  {
004012b6      run();
004012c1      return 0;
004012ad  }
```
Notice that run is immediately called in main, which uses the 'gets' function. This clues us in that this program is vulnerable to buffer overflow
attacks, as the gets function can easily be overflown. We also notice that there is a winner function which is never called - pretty suspicious for
a buffer overflow attack. We can use this buffer overflow to replace the return address of run to winner, thereby getting us the flag!

## Exploit Formation
Using GDB, we can disass run and set a breakpoint at 0x00000000004012ab (just before it returns) to gather some info. Using a test input, I get
the following GDB output:
```
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
─────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────
 RAX  0xc
 RBX  0
 RCX  0x7ffff7e9f887 (write+23) ◂— cmp rax, -0x1000 /* 'H=' */
 RDX  1
 RDI  0x7ffff7fa7a70 (_IO_stdfile_1_lock) ◂— 0
 RSI  1
 R8   0xb
 R9   0
 R10  0x7ffff7d980c8 ◂— 0xf0022000065de
 R11  0x246
 R12  0x7fffffffe118 —▸ 0x7fffffffe39d ◂— '/mnt/c/users/willi/Downloads/reg'
 R13  0x4012ad (main) ◂— push rbp
 R14  0
 R15  0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 ◂— 0
 RBP  0x7fffffffdff0 —▸ 0x7fffffffe000 ◂— 1
 RSP  0x7fffffffdfc0 ◂— 'WILLILOOOO'
 RIP  0x4012ab (run+65) ◂— leave
──────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────
 ► 0x4012ab       <run+65>                        leave
   0x4012ac       <run+66>                        ret                                <main+14>
    ↓
   0x4012bb       <main+14>                       mov    eax, 0     EAX => 0
   0x4012c0       <main+19>                       pop    rbp        RBP => 1
   0x4012c1       <main+20>                       ret                                <__libc_start_call_main+128>
    ↓
   0x7ffff7db4d90 <__libc_start_call_main+128>    mov    edi, eax     EDI => 0
   0x7ffff7db4d92 <__libc_start_call_main+130>    call   exit                        <exit>

   0x7ffff7db4d97 <__libc_start_call_main+135>    call   __nptl_deallocate_tsd       <__nptl_deallocate_tsd>

   0x7ffff7db4d9c <__libc_start_call_main+140>    lock dec dword ptr [rip + 0x1f0505]
   0x7ffff7db4da3 <__libc_start_call_main+147>    sete   al
   0x7ffff7db4da6 <__libc_start_call_main+150>    test   al, al
───────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffdfc0 ◂— 'WILLILOOOO'
01:0008│-028 0x7fffffffdfc8 ◂— 0x10101004f4f /* 'OO' */
02:0010│-020 0x7fffffffdfd0 ◂— 2
03:0018│-018 0x7fffffffdfd8 ◂— 0x1f8bfbff
04:0020│-010 0x7fffffffdfe0 —▸ 0x7fffffffe389 ◂— 0x34365f363878 /* 'x86_64' */
05:0028│-008 0x7fffffffdfe8 ◂— 0x64 /* 'd' */
06:0030│ rbp 0x7fffffffdff0 —▸ 0x7fffffffe000 ◂— 1
07:0038│+008 0x7fffffffdff8 —▸ 0x4012bb (main+14) ◂— mov eax, 0
─────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────
 ► 0         0x4012ab run+65
   1         0x4012bb main+14
   2   0x7ffff7db4d90 __libc_start_call_main+128
   3   0x7ffff7db4e40 __libc_start_main+128
   4         0x4010de _start+46
────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```
Notice that my test input is stored in 0x7fffffffdfc0. Now, I want to find the address of my return address, so I can know how much to overflow the buffer by.
Using 'i f' (info frames), I can find the address of my RIP register to be 0x7fffffffdff8. A simple calculation gets me 0x7fffffffdff8-0x7fffffffdfc0=0x38=56.
Thus, I need 56 arbitrary bytes to overflow my buffer. As for the return address of winner, I can find it using BinaryNinja, which tells me that its address is
00401206. Thus, I can craft the payload by attaching this to the end of 56 arbitrary bytes.

Exploit: [here](exploit.py)

## My Takeaways
This was a textbook changing the return address of the function. It was a pretty early exercise that I did though, so again it gave me great experience playing
around with Binary Ninja and GDB. I mainly learnt how to use the 'i f' command in GDB from this exercise, as well as that the return address of a function is
stored in the rip register, which I found from quick Google searches [here](https://stackoverflow.com/questions/32345320/get-return-address-gdb) and 
[here](https://stackoverflow.com/questions/27429026/understanding-how-eip-rip-register-works).